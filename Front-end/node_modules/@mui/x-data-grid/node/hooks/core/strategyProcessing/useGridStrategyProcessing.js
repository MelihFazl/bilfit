"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGridStrategyProcessing = exports.GRID_STRATEGIES_PROCESSORS = exports.GRID_DEFAULT_STRATEGY = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _toPropertyKey2 = _interopRequireDefault(require("@babel/runtime/helpers/toPropertyKey"));

var React = _interopRequireWildcard(require("react"));

var _useGridApiMethod = require("../../utils/useGridApiMethod");

var _events = require("../../../models/events");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const GRID_DEFAULT_STRATEGY = 'none';
exports.GRID_DEFAULT_STRATEGY = GRID_DEFAULT_STRATEGY;
const GRID_STRATEGIES_PROCESSORS = {
  rowTreeCreation: 'rowTree',
  filtering: 'rowTree',
  sorting: 'rowTree'
};
exports.GRID_STRATEGIES_PROCESSORS = GRID_STRATEGIES_PROCESSORS;

/**
 * Implements a variant of the Strategy Pattern (see https://en.wikipedia.org/wiki/Strategy_pattern)
 *
 * Some plugins contain custom logic that must only be run if the right strategy is active.
 * For instance, the tree data plugin has:
 * - custom row tree creation algorithm.
 * - custom sorting algorithm.
 * - custom filtering algorithm.
 *
 * These plugins must use:
 * - `apiRef.current.unstable_registerStrategyProcessor` to register their processors.
 * - `apiRef.current.unstable_setStrategyAvailability` to tell if their strategy can be used.
 *
 * Some hooks need to run the custom logic of the active strategy.
 * For instance, the `useGridFiltering` wants to run:
 * - the tree data filtering if the tree data is the current way of grouping rows.
 * - the row grouping filtering if the row grouping is the current way of grouping rows.
 * - the flat filtering if there is no grouping of the rows (equivalent to the "none" strategy).
 *
 * These hooks must use:
 * - `apiRef.current.unstable_applyStrategyProcessor` to run a processor.
 * - `GridEvents.strategyAvailabilityChange` to update something when the active strategy changes.
 *    Warning: Be careful not to apply the processor several times.
 *    For instance `GridEvents.rowsSet` is fired by `useGridRows` whenever the active strategy changes.
 *    So listening to both would most likely run your logic twice.
 * - `GridEvents.activeStrategyProcessorChange` to update something when the processor of the active strategy changes
 *
 * Each processor name is part of a strategy group which can only have one active strategy at the time.
 */
const useGridStrategyProcessing = apiRef => {
  const availableStrategies = React.useRef(new Map());
  const strategiesCache = React.useRef({});
  const registerStrategyProcessor = React.useCallback((strategyName, processorName, processor) => {
    const cleanup = () => {
      const _ref = strategiesCache.current[processorName],
            otherProcessors = (0, _objectWithoutPropertiesLoose2.default)(_ref, [strategyName].map(_toPropertyKey2.default));
      strategiesCache.current[processorName] = otherProcessors;
    };

    if (!strategiesCache.current[processorName]) {
      strategiesCache.current[processorName] = {};
    }

    const groupPreProcessors = strategiesCache.current[processorName];
    const previousProcessor = groupPreProcessors[strategyName];
    groupPreProcessors[strategyName] = processor;

    if (!previousProcessor || previousProcessor === processor) {
      return cleanup;
    }

    if (strategyName === apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName])) {
      apiRef.current.publishEvent(_events.GridEvents.activeStrategyProcessorChange, processorName);
    }

    return cleanup;
  }, [apiRef]);
  const applyStrategyProcessor = React.useCallback((processorName, params) => {
    const activeStrategy = apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName]);

    if (activeStrategy == null) {
      throw new Error("Can't apply a strategy processor before defining an active strategy");
    }

    const groupCache = strategiesCache.current[processorName];

    if (!groupCache || !groupCache[activeStrategy]) {
      throw new Error(`No processor found for processor "${processorName}" on strategy "${activeStrategy}"`);
    }

    const processor = groupCache[activeStrategy];
    return processor(params);
  }, [apiRef]);
  const getActiveStrategy = React.useCallback(strategyGroup => {
    var _availableStrategyEnt;

    const strategyEntries = Array.from(availableStrategies.current.entries());
    const availableStrategyEntry = strategyEntries.find(([, strategy]) => {
      if (strategy.group !== strategyGroup) {
        return false;
      }

      return strategy.isAvailable();
    });
    return (_availableStrategyEnt = availableStrategyEntry == null ? void 0 : availableStrategyEntry[0]) != null ? _availableStrategyEnt : GRID_DEFAULT_STRATEGY;
  }, []);
  const setStrategyAvailability = React.useCallback((strategyGroup, strategyName, isAvailable) => {
    availableStrategies.current.set(strategyName, {
      group: strategyGroup,
      isAvailable
    });
    apiRef.current.publishEvent(_events.GridEvents.strategyAvailabilityChange);
  }, [apiRef]);
  const strategyProcessingApi = {
    unstable_registerStrategyProcessor: registerStrategyProcessor,
    unstable_applyStrategyProcessor: applyStrategyProcessor,
    unstable_getActiveStrategy: getActiveStrategy,
    unstable_setStrategyAvailability: setStrategyAvailability
  };
  (0, _useGridApiMethod.useGridApiMethod)(apiRef, strategyProcessingApi, 'GridStrategyProcessing');
};

exports.useGridStrategyProcessing = useGridStrategyProcessing;